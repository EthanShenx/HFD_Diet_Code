panel.grid.minor = element_blank(),
panel.border = element_rect(color = "gray80", fill = NA, linewidth = 0.8),
legend.position = c(0.85, 0.15),
legend.background = element_rect(fill = "white", color = "gray80"),
plot.margin = unit(c(1, 1, 1, 1), "cm"),
plot.caption = element_text(size = 10, color = "gray50", hjust = 0, margin = margin(t = 10))
)
# 组合图形和表格
final_plot <- ggarrange(
p,
table_grob,
ncol = 1,
nrow = 2,
heights = c(0.8, 0.2)
)
# 输出图形
print(final_plot)
# 主图绘制
p <- ggplot(rank_df, aes(x = rank_percent_my, y = rank_percent_ncbi)) +
# 使用hex分箱显示高密度点
geom_hex(bins = 70, alpha = 0.8) +
scale_fill_gradientn(
colors = c("#f0f0f0", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"),
name = "Density",
trans = "log10",
breaks = c(1, 10, 100, 1000)
) +
# y = x 参考线
geom_abline(
intercept = 0,
slope = 1,
color = "#d62728",
linetype = "longdash",
linewidth = 1.2,
alpha = 0.8
) +
# 坐标轴设置
scale_x_continuous(
labels = scales::percent,
breaks = seq(0, 1, by = 0.2),
limits = c(0, 1)
) +
scale_y_continuous(
labels = scales::percent,
breaks = seq(0, 1, by = 0.2),
limits = c(0, 1)
) +
# 标签和标题
labs(
title = "Gene expression rank consistency analysis",
subtitle = "Comparison of gene rankings between my data and NCBI",
x = "Our Data (Rank Percentile)",
y = "NCBI Data (Rank Percentile)",
caption = "Points colored by density; Dashed line represents perfect rank agreement"
) +
# 主题设置
theme_pubclean() +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold", margin = margin(b = 10)),
plot.subtitle = element_text(hjust = 0.5, size = 12, color = "gray40", margin = margin(b = 15)),
axis.title = element_text(size = 13, face = "plain"),
axis.text = element_text(size = 11, color = "black"),
panel.grid.major = element_line(color = "gray90", linewidth = 0.3),
panel.grid.minor = element_blank(),
panel.border = element_rect(color = "gray80", fill = NA, linewidth = 0.8),
legend.position = c(0.85, 0.32),
legend.background = element_rect(fill = "white", color = "gray80"),
plot.margin = unit(c(1, 1, 1, 1), "cm"),
plot.caption = element_text(size = 10, color = "gray50", hjust = 0, margin = margin(t = 10))
)
# 组合图形和表格
final_plot <- ggarrange(
p,
table_grob,
ncol = 1,
nrow = 2,
heights = c(0.8, 0.2)
)
# 输出图形
print(final_plot)
library(systemfonts)
system_fonts()
df <- data.frame(
Age = c(1, 2, 3, 4, 5, 6),
Weight = c(2, 4, 6, 8, 10, 11)
)
ggplot(df, aes(x = Age, y = Weight)) +
geom_point(size = 2) +
geom_smooth(aes(color = "Fitting line"), method = "lm", se = FALSE) +  # map a label to color
labs(x = "Age, weeks", y = "Body weight, g") +
theme_minimal(base_size = 14) +
theme(
legend.position = "bottom",
legend.title = element_blank()
) +
scale_color_manual(values = c("Fitting line" = "red"))  # match color to label
library(ggplot2)
ggplot(df, aes(x = Age, y = Weight)) +
geom_point(size = 2) +
geom_smooth(aes(color = "Fitting line"), method = "lm", se = FALSE) +  # map a label to color
labs(x = "Age, weeks", y = "Body weight, g") +
theme_minimal(base_size = 14) +
theme(
legend.position = "bottom",
legend.title = element_blank()
) +
scale_color_manual(values = c("Fitting line" = "red"))  # match color to label
ggplot(df, aes(x = Age, y = Weight)) +
geom_point(aes(shape = "Primary points"), color = "black") +
geom_smooth(aes(color = "Model"), method = "lm", se = FALSE) +
scale_color_manual(values = c("Model" = "red")) +
scale_shape_manual(values = c("Primary points" = 1)) +
labs(x = "Speed, km/h", y = "Distance to stop, m") +
theme_minimal(base_size = 14) +
theme(
legend.title = element_blank(),
legend.position = "right" # bottom/top
)
P <- matrix(c(
0.80, 0.20, 0.00,
0.00, 0.70, 0.30,
0.00, 0.00, 1.00
), nrow = 3, byrow = TRUE)
# Initial state vector: conditions at time step 0
state_vec <- c(0.99, 0.01, 0.00)  # The sum is 100% of the population
state_after_one <- P %*% state_vec
print(state_after_one)
# Initial state vector
state_vec <- c(0.99, 0.01, 0.00)
steps <- 150
states_vec_over_time <- matrix(0, nrow = steps, ncol = 3)
states_vec_over_time[1, ] <- state_vec
for (t in 2:steps) {
states_vec_over_time[t, ] <- states_vec_over_time[t-1, ] %*% P
}
# Plot
matplot(1:steps, states_vec_over_time, type = "l", lty = 1, col = c("blue", "red", "green"),
xlab = "Time Step", ylab = "Proportion",
main = "Markov Chain Infection Modeling")
legend("right", legend = c("Susceptible", "Infected", "Recovered"),
col = c("blue", "red", "green"), lty = 1, bty = "n")
# Calculate state at time step 20 using X0 %*% P^20
state_at_10 <- state_vec %*% (P %^% 10)
P <- matrix(c(
0.80, 0.20, 0.00,
0.00, 0.70, 0.30,
0.00, 0.00, 1.00
), nrow = 3, byrow = TRUE)
P <- t(p)
P <- t(P)
# Initial state vector: conditions at time step 0
state_vec <- c(0.99, 0.01, 0.00)  # The sum is 100% of the population
state_after_one <- P %*% state_vec
print(state_after_one)
# Initial state vector
state_vec <- c(0.99, 0.01, 0.00)
steps <- 150
states_vec_over_time <- matrix(0, nrow = steps, ncol = 3)
states_vec_over_time[1, ] <- state_vec
for (t in 2:steps) {
states_vec_over_time[t, ] <- states_vec_over_time[t-1, ] %*% P
}
# Plot
matplot(1:steps, states_vec_over_time, type = "l", lty = 1, col = c("blue", "red", "green"),
xlab = "Time Step", ylab = "Proportion",
main = "Markov Chain Infection Modeling")
legend("right", legend = c("Susceptible", "Infected", "Recovered"),
col = c("blue", "red", "green"), lty = 1, bty = "n")
# Calculate state at time step 20 using X0 %*% P^20
state_at_10 <- state_vec %*% (P %^% 10)
# Initial state vector
state_vec <- c(0.99, 0.01, 0.00)
steps <- 150
states_vec_over_time <- matrix(0, nrow = steps, ncol = 3)
states_vec_over_time[1, ] <- state_vec
for (t in 2:steps) {
states_vec_over_time[t, ] <- states_vec_over_time[t-1, ] %*% P
}
# Plot
matplot(1:steps, states_vec_over_time, type = "l", lty = 1, col = c("blue", "red", "green"),
xlab = "Time Step", ylab = "Proportion",
main = "Markov Chain Infection Modeling")
legend("right", legend = c("Susceptible", "Infected", "Recovered"),
col = c("blue", "red", "green"), lty = 1, bty = "n")
# Plot
matplot(1:steps, states_vec_over_time, type = "l", lty = 1, col = c("blue", "red", "green"),
xlab = "Time Step", ylab = "Proportion",
main = "Markov Chain Infection Modeling")
P <- matrix(c(
0.80, 0.20, 0.00,
0.00, 0.70, 0.30,
0.00, 0.00, 1.00
), nrow = 3, byrow = TRUE)
# Initial state vector
state_vec <- c(0.99, 0.01, 0.00)
steps <- 150
states_vec_over_time <- matrix(0, nrow = steps, ncol = 3)
states_vec_over_time[1, ] <- state_vec
for (t in 2:steps) {
states_vec_over_time[t, ] <- states_vec_over_time[t-1, ] %*% P
}
# Plot
matplot(1:steps, states_vec_over_time, type = "l", lty = 1, col = c("blue", "red", "green"),
xlab = "Time Step", ylab = "Proportion",
main = "Markov Chain Infection Modeling")
P <- matrix(c(
0.80, 0.20, 0.00,
0.00, 0.70, 0.30,
0.00, 0.00, 1.00
), nrow = 3, byrow = TRUE)
P <- t(P)
# Initial state vector
state_vec <- c(0.99, 0.01, 0.00)
steps <- 150
states_vec_over_time <- matrix(0, nrow = steps, ncol = 3)
states_vec_over_time[1, ] <- state_vec
for (t in 2:steps) {
states_vec_over_time[t, ] <- P %*% states_vec_over_time[t-1, ]
}
# Plot
matplot(1:steps, states_vec_over_time, type = "l", lty = 1, col = c("blue", "red", "green"),
xlab = "Time Step", ylab = "Proportion",
main = "Markov Chain Infection Modeling")
anova
view(anova)
res <- eigen(t(P))
res$values
res$vectors[, 1] # first eigenvector
res <- eigen(P)
res$values
res$vectors[, 1] # first eigenvector
source("03-01ORA&GSEA.R")
source("./03-01ORA&GSEA.R")
source("/Users/coellearth/Desktop/Mammary_Gland_Diet_Project/3Enrichment/03-01ORA&GSEA.R")
View(down_go)
View(deg)
View(deg_list)
View(deg_list)
cell_types <- unique(deg$cell_type)
source("/Users/coellearth/Desktop/Mammary_Gland_Diet_Project/3Enrichment/03-99ORAforSimilarity.R")
View(Adipo_Up_KEGG)
# 1. Helper: extract gene sets and adjusted p-values from an enrichResult
extract_gene_sets <- function(enrich_obj) {
# enrich_obj@result must have columns: ID, geneID, p.adjust
genes <- strsplit(enrich_obj@result$geneID, "/")
names(genes) <- enrich_obj@result$ID
pvals <- setNames(enrich_obj@result$p.adjust, enrich_obj@result$ID)
list(genes = genes, p = pvals)
}
go_data       <- extract_gene_sets(Adipo_Down_GO)
View(go_data)
go_data       <- extract_gene_sets(Adipo_Down_GO)
kegg_data     <- extract_gene_sets(Adipo_Down_KEGG)
reactome_data <- extract_gene_sets(Adipo_Down_Reactome)
# 2.1 Prepare GO semantic data for human (here using Biological Process; switch to "MF" or "CC" if needed)
go_sem_data <- get_GO_data(organism = "mouse", ont = "BP")
library(simplifyEnrichment)
library(igraph)
library(ggraph)
library(igraph)
library(RColorBrewer)
library(pheatmap)
library(ggdendro)
# 2.1 Prepare GO semantic data for human (here using Biological Process; switch to "MF" or "CC" if needed)
go_sem_data <- get_GO_data(organism = "mouse", ont = "BP")
library(GOSemSim)
go_sem_data <- get_GO_data(organism = "mouse", ont = "BP")
semData_mouse_BP <- godata(
OrgDb     = "org.Mm.eg.db",
ont       = "BP",
computeIC = FALSE
)
View(semData_mouse_BP)
semData_mouse_BP <- godata(
OrgDb     = "org.Mm.eg.db",
ont       = "BP",
computeIC = FALSE
)
# 2.2 Compute pairwise semantic similarity matrix for GO IDs
go_sim_mat <- GO_similarity(
terms   = names(go_data$genes),   # your vector of GO IDs
semData = semData_mouse_BP,       # from GOSemSim::godata()
method  = "Wang"                  # Wang semantic similarity
)
# 2.2 Compute pairwise semantic similarity matrix for GO IDs
go_sim_mat <- GO_similarity(
go_id   = names(go_data$genes),    # vector of your GO IDs
ont     = "BP",                    # BP / CC / MF
db      = "org.Mm.eg.db",          # or pass the OrgDb object
measure = "Sim_Wang_2007"          # Wang semantic similarity
)
# 2.2 Compute pairwise semantic similarity matrix for GO IDs
go_sim_mat <- GO_similarity(
go_id   = names(go_data$genes),    # vector of your GO IDs
ont     = "BP",                    # BP / CC / MF
db      = "org.Mm.eg.db",          # or pass the OrgDb object
measure = "Wang"          # Wang semantic similarity
)
View(go_sim_mat)
# 2.3 Threshold at similarity > 0.7, build graph & detect communities
go_sim_mat[go_sim_mat < 0.7] <- 0
g_go <- graph_from_adjacency_matrix(go_sim_mat, mode = "undirected", weighted = TRUE, diag = FALSE)
View(g_go)
g_go <- delete_edges(g_go, E(g_go)[weight == 0])
View(g_go)
# 2.4 Community detection (e.g. Louvain)
go_comm    <- cluster_louvain(g_go)
go_members <- membership(go_comm)
# 2.5 Choose representative GO term per module (smallest adjusted P)
go_reps <- sapply(unique(go_members), function(mod) {
ids <- names(go_members)[go_members == mod]
ids[which.min(go_data$p[ids])]
})
# 2.5 Choose representative GO term per module (smallest adjusted P)
go_reps
go_reps
jaccard_matrix <- function(gene_list) {
terms <- names(gene_list)
n <- length(terms)
mat <- matrix(0, n, n, dimnames = list(terms, terms))
for (i in seq_len(n)) {
for (j in seq_len(i)) {
a <- gene_list[[i]]
b <- gene_list[[j]]
sim <- length(intersect(a, b)) / length(union(a, b))
mat[i, j] <- sim
mat[j, i] <- sim
}
}
mat
}
process_similarity <- function(data, threshold = 0.5) {
sim <- jaccard_matrix(data$genes)
sim[sim < threshold] <- 0
g <- graph_from_adjacency_matrix(sim, mode = "undirected", weighted = TRUE, diag = FALSE)
g <- delete_edges(g, E(g)[weight == 0])
comm <- cluster_louvain(g)
mem  <- membership(comm)
reps <- sapply(unique(mem), function(mod) {
ids <- names(mem)[mem == mod]
ids[which.min(data$p[ids])]
})
list(graph = g, modules = mem, reps = reps)
}
kegg_res     <- process_similarity(Adipo_Down_KEGG, threshold = 0.5)
kegg_res     <- process_similarity(kegg_data, threshold = 0.5)
reactome_res <- process_similarity(reactome_data, threshold = 0.5)
View(kegg_res)
# 4.1 Collect all representative IDs and their gene sets + p-values
merged_ids    <- c(go_reps, kegg_res$reps, reactome_res$reps)
merged_genes  <- c(go_data$genes[go_reps],
kegg_data$genes[kegg_res$reps],
reactome_data$genes[reactome_res$reps])
merged_p      <- c(go_data$p[go_reps],
kegg_data$p[kegg_res$reps],
reactome_data$p[reactome_res$reps])
# 4.2 Build global Jaccard similarity network (threshold 0.5)
merged_sim <- jaccard_matrix(merged_genes)
merged_sim[merged_sim < 0.5] <- 0
g_merged <- graph_from_adjacency_matrix(merged_sim, mode = "undirected", weighted = TRUE, diag = FALSE)
g_merged <- delete_edges(g_merged, E(g_merged)[weight == 0])
# 4.3 Community detection via edge betweenness (yields a dendrogram)
merged_comm    <- cluster_edge_betweenness(g_merged, directed = FALSE)
merged_members <- membership(merged_comm)
# 4.4 Pick representative per global module (smallest adjusted P)
merged_reps <- sapply(unique(merged_members), function(mod) {
ids <- names(merged_members)[merged_members == mod]
ids[which.min(merged_p[ids])]
})
# List of modules
final_modules <- split(names(merged_members), merged_members)
View(final_modules)
plot(as.dendrogram(merged_comm),
main = "Dendrogram of Merged Pathway Similarity Network")
# 1. NETWORK PLOT: pathway similarity network colored by module, reps labeled
# ------------------------------------------------------------------------------
# Annotate graph vertices with module and rep‐status
V(g_merged)$module <- as.factor(merged_members[V(g_merged)$name] )
V(g_merged)$is_rep <- V(g_merged)$name %in% merged_reps
V(g_merged)$label  <- ifelse(V(g_merged)$is_rep, V(g_merged)$name, NA)
# Choose a palette with enough distinct colors
palette <- brewer.pal(max(length(unique(merged_members)), 3), "Set3")
# Plot with ggraph
set.seed(42)  # for reproducible layout
ggraph(g_merged, layout = "fr") +
# edges weighted by similarity
geom_edge_link(aes(width = weight), alpha = 0.4) +
# nodes colored by module; reps larger
geom_node_point(aes(color = module, size = is_rep)) +
# label only the representative nodes
geom_node_text(aes(label = label), repel = TRUE, vjust = 1.5, size = 3) +
scale_color_manual(values = palette) +
scale_size_manual(values = c(`FALSE` = 2, `TRUE` = 5)) +
theme_void() +
labs(title    = "Merged Pathway Similarity Network",
subtitle = "Nodes = pathways/GO terms; colored by module",
color    = "Module",
size     = "Representative")
ggraph(g_merged, layout = "fr") +
# edges weighted by similarity
geom_edge_link(aes(width = weight), alpha = 0.4) +
# nodes colored by module; reps larger
geom_node_point(aes(color = module, size = is_rep)) +
# label only the representative nodes
geom_node_text(aes(label = label), repel = TRUE, vjust = 1.5, size = 3) +
scale_size_manual(values = c(`FALSE` = 2, `TRUE` = 5)) +
theme_void() +
labs(title    = "Merged Pathway Similarity Network",
subtitle = "Nodes = pathways/GO terms; colored by module",
color    = "Module",
size     = "Representative")
ggraph(g_merged, layout = "fr") +
# edges weighted by similarity
geom_edge_link(aes(width = weight), alpha = 0.4) +
# nodes colored by module; reps larger
geom_node_point(aes(color = module, size = is_rep)) +
# label only the representative nodes
geom_node_text(aes(label = label), repel = TRUE, vjust = 1.5, size = 3) +
theme_void() +
labs(title    = "Merged Pathway Similarity Network",
subtitle = "Nodes = pathways/GO terms; colored by module",
color    = "Module",
size     = "Representative")
library(scales)
# Choose a palette with enough distinct colors
palette <- hue_pal()(length(unique(merged_members)))
# Plot with ggraph
set.seed(42)  # for reproducible layout
ggraph(g_merged, layout = "fr") +
# edges weighted by similarity
geom_edge_link(aes(width = weight), alpha = 0.4) +
# nodes colored by module; reps larger
geom_node_point(aes(color = module, size = is_rep)) +
# label only the representative nodes
geom_node_text(aes(label = label), repel = TRUE, vjust = 1.5, size = 3) +
scale_color_manual(values = palette) +
scale_size_manual(values = c(`FALSE` = 2, `TRUE` = 5)) +
theme_void() +
labs(title    = "Merged Pathway Similarity Network",
subtitle = "Nodes = pathways/GO terms; colored by module",
color    = "Module",
size     = "Representative")
ggraph(g_merged, layout = "fr") +
# edges weighted by similarity
geom_edge_link(aes(width = weight), alpha = 0.4) +
# nodes colored by module; reps larger
geom_node_point(aes(color = module, size = is_rep)) +
# label only the representative nodes
geom_node_text(aes(label = label), repel = TRUE, vjust = 1.5, size = 3) +
scale_color_manual(values = palette) +
scale_size_manual(values = c(`FALSE` = 2, `TRUE` = 5)) +
theme_void() +
labs(title    = "Merged Pathway Similarity Network",
subtitle = "Nodes = pathways/GO terms; colored by module",
color    = "Module",
size     = "Representative")
# 计算每个模块的最小 p 值
mod_pvals <- tapply(merged_p[names(merged_members)], merged_members, min)
top_modules <- names(sort(mod_pvals))[1:10]
# 过滤节点
keep_nodes <- names(merged_members)[merged_members %in% top_modules]
subgraph_topmods <- induced_subgraph(g_merged, vids = keep_nodes)
# 更新属性
V(subgraph_topmods)$module <- as.factor(merged_members[V(subgraph_topmods)$name])
V(subgraph_topmods)$is_rep <- V(subgraph_topmods)$name %in% merged_reps
V(subgraph_topmods)$label  <- ifelse(V(subgraph_topmods)$is_rep, V(subgraph_topmods)$name, NA)
# 可视化
ggraph(subgraph_topmods, layout = "fr") +
geom_edge_link(aes(width = weight), alpha = 0.4) +
geom_node_point(aes(color = module, size = is_rep)) +
geom_node_text(aes(label = label), repel = TRUE, size = 3) +
scale_color_manual(values = hue_pal()(length(unique(V(subgraph_topmods)$module)))) +
scale_size_manual(values = c(`FALSE` = 0, `TRUE` = 5)) +
theme_void() +
labs(title = "Top 10 Modules",
subtitle = "Only representative terms labeled",
color = "Module",
size = "Representative")
# 只保留代表节点构成的子图
subgraph_reps <- induced_subgraph(g_merged, vids = merged_reps)
# 可视化
ggraph(subgraph_reps, layout = "fr") +
geom_edge_link(aes(width = weight), alpha = 0.5) +
geom_node_point(aes(color = module), size = 5) +
geom_node_text(aes(label = name), repel = TRUE, vjust = 1.5, size = 3) +
scale_color_manual(values = palette) +
theme_void() +
labs(title = "Simplified Network (Only Representative Terms)",
subtitle = "One term per module")
# 可视化
ggraph(subgraph_reps, layout = "fr") +
geom_edge_link(aes(width = weight), alpha = 0.5) +
geom_node_point(aes(color = module), size = 5) +
geom_node_text(aes(label = name), repel = TRUE, vjust = 1.5, size = 3) +
scale_color_manual(values = palette) +
theme_void() +
labs(title = "Simplified Network (Only Representative Terms)",
subtitle = "One term per module")
top_ids <- names(sort(merged_p))[1:20]
subgraph_top <- induced_subgraph(g_merged, vids = top_ids)
# 可视化
V(subgraph_top)$module <- as.factor(merged_members[V(subgraph_top)$name])
V(subgraph_top)$is_rep <- V(subgraph_top)$name %in% merged_reps
V(subgraph_top)$label  <- V(subgraph_top)$name
ggraph(subgraph_top, layout = "fr") +
geom_edge_link(aes(width = weight), alpha = 0.4) +
geom_node_point(aes(color = module), size = 5) +
geom_node_text(aes(label = label), repel = TRUE, size = 3) +
scale_color_manual(values = hue_pal()(length(unique(V(subgraph_top)$module)))) +
theme_void() +
labs(title = "Top 20 Most Significant Terms",
subtitle = "Based on adjusted p-values")

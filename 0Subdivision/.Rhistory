) +
# 坐标轴和对数转换
scale_x_continuous(
trans = "log10",
breaks = scales::trans_breaks("log10", function(x) 10^x),
labels = scales::trans_format("log10", scales::math_format(10^.x))
) +
scale_y_continuous(
trans = "log10",
breaks = scales::trans_breaks("log10", function(x) 10^x),
labels = scales::trans_format("log10", scales::math_format(10^.x))
) +
# 标签和标题
labs(
title = "Transcript expression correlation analysis",
subtitle = "Comparison of TPM values between my data and NCBI",
x = "Our data (TPM, log10 scale)",
y = "NCBI data (TPM, log10 scale)",
caption = "Data points colored by density; Dashed line represents y = x reference"
) +
# 主题设置
theme_pubclean() +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold", margin = margin(b = 10)),
plot.subtitle = element_text(hjust = 0.5, size = 12, color = "gray40", margin = margin(b = 15)),
axis.title = element_text(size = 13, face = "plain"),
axis.text = element_text(size = 11, color = "black"),
panel.grid.major = element_line(color = "gray90", linewidth = 0.3),
panel.grid.minor = element_blank(),
panel.border = element_rect(color = "gray80", fill = NA, linewidth = 0.8),
legend.position = c(0.85, 0.31),
legend.background = element_rect(fill = "white", color = "gray80"),
plot.margin = unit(c(1, 1, 1, 1), "cm"),
plot.caption = element_text(size = 10, color = "gray50", hjust = 0, margin = margin(t = 10))
)
# 在图形上添加统计表格
final_plot <- ggarrange(
p,
table_grob,
ncol = 1,
nrow = 2,
heights = c(0.8, 0.2)
)
get_high_exp_genes <- function(count_df, top_percent) {
count_col <- grep("TPM", names(count_df), value = TRUE)
count_df %>%
top_frac(n = top_percent, wt = .data[[count_col]]) %>%
pull(GeneID)
}
top_levels <- c(0.1, 0.2)
gene_lists <- list()
for (i in seq_along(top_levels)) {
gene_lists[[paste0("My top", top_levels[i] * 100, "%")]] <- get_high_exp_genes(my_count, top_levels[i])
gene_lists[[paste0("NCBI top", top_levels[i] * 100, "%")]] <- get_high_exp_genes(ncbi_count, top_levels[i])
}
ggVennDiagram(gene_lists, label_alpha = 0.6) +
scale_fill_gradient(low = "#ADD8E6", high = "#FF6347") +
theme(legend.position = "none")
p <- ggVennDiagram(gene_lists, label_alpha = 0.6) +
scale_fill_gradient(low = "#ADD8E6", high = "#FF4500") +
theme_minimal() +
theme(
legend.position = "none",
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
plot.background = element_rect(fill = "white"),
panel.grid = element_blank()
) +
labs(
title = "Top expressed genes overlap",
subtitle = "Comparison of top 10% & 20% Genes in my count matrix vs. NCBI"
)
# 显示图形
print(p)
get_high_exp_genes <- function(count_df, top_percent) {
count_col <- grep("TPM", names(count_df), value = TRUE)
count_df %>%
top_frac(n = top_percent, wt = .data[[count_col]]) %>%
pull(GeneID)
}
top_levels <- c(0.1, 0.2)
gene_lists <- list()
for (i in seq_along(top_levels)) {
gene_lists[[paste0("My top", top_levels[i] * 100, "%")]] <- get_high_exp_genes(my_count, top_levels[i])
gene_lists[[paste0("NCBI top", top_levels[i] * 100, "%")]] <- get_high_exp_genes(ncbi_count, top_levels[i])
}
ggVennDiagram(gene_lists, label_alpha = 0.6) +
scale_fill_gradient(low = "#ADD8E6", high = "#FF6347") +
theme(legend.position = "none")
library(ggplot2)
library(ggpubr)
library(ggthemes)
library(hexbin)
# 计算排名和相关性
rank_my <- shared_genes %>%
arrange(desc(TPM_my)) %>%
mutate(rank_my = row_number())
rank_ncbi <- shared_genes %>%
arrange(desc(TPM_ncbi)) %>%
mutate(rank_ncbi = row_number())
rank_combined <- inner_join(rank_my, rank_ncbi, by = "GeneID")
# 相关性检验
kendall_tau <- cor.test(rank_combined$rank_my,
rank_combined$rank_ncbi,
method = "kendall")
spearman_rho <- cor.test(rank_combined$rank_my,
rank_combined$rank_ncbi,
method = "spearman")
# 格式化 p 值
format_p <- function(p) {
ifelse(p < 0.001, "< 0.001", paste0("= ", format.pval(p, digits = 3)))
}
# 构建统计信息表格
stat_table <- data.frame(
Test = c("Kendall's τ", "Spearman's ρ"),
Estimate = c(
round(kendall_tau$estimate, 3),
round(spearman_rho$estimate, 3)
),
P_value = c(
format_p(kendall_tau$p.value),
format_p(spearman_rho$p.value)
)
)
# 创建表格图形对象
table_grob <- ggtexttable(
stat_table,
rows = NULL,
theme = ttheme(
base_style = "light",
base_size = 10,
padding = unit(c(4, 4), "mm"),
colnames.style = colnames_style(fill = "#f7f7f7", face = "bold"),
tbody.style = tbody_style(fill = c("white", "#f7f7f7"))
)
)
# 准备绘图数据
rank_df <- rank_combined %>%
mutate(
rank_percent_my = rank_my/max(rank_my),
rank_percent_ncbi = rank_ncbi/max(rank_ncbi)
)
# 主图绘制
p <- ggplot(rank_df, aes(x = rank_percent_my, y = rank_percent_ncbi)) +
# 使用hex分箱显示高密度点
geom_hex(bins = 70, alpha = 0.8) +
scale_fill_gradientn(
colors = c("#f0f0f0", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"),
name = "Density",
trans = "log10",
breaks = c(1, 10, 100, 1000)
) +
# y = x 参考线
geom_abline(
intercept = 0,
slope = 1,
color = "#d62728",
linetype = "longdash",
linewidth = 1.2,
alpha = 0.8
) +
# 坐标轴设置
scale_x_continuous(
labels = scales::percent,
breaks = seq(0, 1, by = 0.2),
limits = c(0, 1)
) +
scale_y_continuous(
labels = scales::percent,
breaks = seq(0, 1, by = 0.2),
limits = c(0, 1)
) +
# 标签和标题
labs(
title = "Gene Rank Consistency Analysis",
subtitle = "Comparison of gene rankings between our data and NCBI",
x = "Our Data (Rank Percentile)",
y = "NCBI Data (Rank Percentile)",
caption = "Points colored by density; Dashed line represents perfect rank agreement"
) +
# 主题设置
theme_pubclean() +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold", margin = margin(b = 10)),
plot.subtitle = element_text(hjust = 0.5, size = 12, color = "gray40", margin = margin(b = 15)),
axis.title = element_text(size = 13, face = "plain"),
axis.text = element_text(size = 11, color = "black"),
panel.grid.major = element_line(color = "gray90", linewidth = 0.3),
panel.grid.minor = element_blank(),
panel.border = element_rect(color = "gray80", fill = NA, linewidth = 0.8),
legend.position = c(0.85, 0.15),
legend.background = element_rect(fill = "white", color = "gray80"),
plot.margin = unit(c(1, 1, 1, 1), "cm"),
plot.caption = element_text(size = 10, color = "gray50", hjust = 0, margin = margin(t = 10))
)
# 组合图形和表格
final_plot <- ggarrange(
p,
table_grob,
ncol = 1,
nrow = 2,
heights = c(0.8, 0.2)
)
# 输出图形
print(final_plot)
# 主图绘制
p <- ggplot(rank_df, aes(x = rank_percent_my, y = rank_percent_ncbi)) +
# 使用hex分箱显示高密度点
geom_hex(bins = 70, alpha = 0.8) +
scale_fill_gradientn(
colors = c("#f0f0f0", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"),
name = "Density",
trans = "log10",
breaks = c(1, 10, 100, 1000)
) +
# y = x 参考线
geom_abline(
intercept = 0,
slope = 1,
color = "#d62728",
linetype = "longdash",
linewidth = 1.2,
alpha = 0.8
) +
# 坐标轴设置
scale_x_continuous(
labels = scales::percent,
breaks = seq(0, 1, by = 0.2),
limits = c(0, 1)
) +
scale_y_continuous(
labels = scales::percent,
breaks = seq(0, 1, by = 0.2),
limits = c(0, 1)
) +
# 标签和标题
labs(
title = "Gene expression rank consistency analysis",
subtitle = "Comparison of gene rankings between my data and NCBI",
x = "Our Data (Rank Percentile)",
y = "NCBI Data (Rank Percentile)",
caption = "Points colored by density; Dashed line represents perfect rank agreement"
) +
# 主题设置
theme_pubclean() +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold", margin = margin(b = 10)),
plot.subtitle = element_text(hjust = 0.5, size = 12, color = "gray40", margin = margin(b = 15)),
axis.title = element_text(size = 13, face = "plain"),
axis.text = element_text(size = 11, color = "black"),
panel.grid.major = element_line(color = "gray90", linewidth = 0.3),
panel.grid.minor = element_blank(),
panel.border = element_rect(color = "gray80", fill = NA, linewidth = 0.8),
legend.position = c(0.85, 0.32),
legend.background = element_rect(fill = "white", color = "gray80"),
plot.margin = unit(c(1, 1, 1, 1), "cm"),
plot.caption = element_text(size = 10, color = "gray50", hjust = 0, margin = margin(t = 10))
)
# 组合图形和表格
final_plot <- ggarrange(
p,
table_grob,
ncol = 1,
nrow = 2,
heights = c(0.8, 0.2)
)
# 输出图形
print(final_plot)
library(systemfonts)
system_fonts()
df <- data.frame(
Age = c(1, 2, 3, 4, 5, 6),
Weight = c(2, 4, 6, 8, 10, 11)
)
ggplot(df, aes(x = Age, y = Weight)) +
geom_point(size = 2) +
geom_smooth(aes(color = "Fitting line"), method = "lm", se = FALSE) +  # map a label to color
labs(x = "Age, weeks", y = "Body weight, g") +
theme_minimal(base_size = 14) +
theme(
legend.position = "bottom",
legend.title = element_blank()
) +
scale_color_manual(values = c("Fitting line" = "red"))  # match color to label
library(ggplot2)
ggplot(df, aes(x = Age, y = Weight)) +
geom_point(size = 2) +
geom_smooth(aes(color = "Fitting line"), method = "lm", se = FALSE) +  # map a label to color
labs(x = "Age, weeks", y = "Body weight, g") +
theme_minimal(base_size = 14) +
theme(
legend.position = "bottom",
legend.title = element_blank()
) +
scale_color_manual(values = c("Fitting line" = "red"))  # match color to label
ggplot(df, aes(x = Age, y = Weight)) +
geom_point(aes(shape = "Primary points"), color = "black") +
geom_smooth(aes(color = "Model"), method = "lm", se = FALSE) +
scale_color_manual(values = c("Model" = "red")) +
scale_shape_manual(values = c("Primary points" = 1)) +
labs(x = "Speed, km/h", y = "Distance to stop, m") +
theme_minimal(base_size = 14) +
theme(
legend.title = element_blank(),
legend.position = "right" # bottom/top
)
P <- matrix(c(
0.80, 0.20, 0.00,
0.00, 0.70, 0.30,
0.00, 0.00, 1.00
), nrow = 3, byrow = TRUE)
# Initial state vector: conditions at time step 0
state_vec <- c(0.99, 0.01, 0.00)  # The sum is 100% of the population
state_after_one <- P %*% state_vec
print(state_after_one)
# Initial state vector
state_vec <- c(0.99, 0.01, 0.00)
steps <- 150
states_vec_over_time <- matrix(0, nrow = steps, ncol = 3)
states_vec_over_time[1, ] <- state_vec
for (t in 2:steps) {
states_vec_over_time[t, ] <- states_vec_over_time[t-1, ] %*% P
}
# Plot
matplot(1:steps, states_vec_over_time, type = "l", lty = 1, col = c("blue", "red", "green"),
xlab = "Time Step", ylab = "Proportion",
main = "Markov Chain Infection Modeling")
legend("right", legend = c("Susceptible", "Infected", "Recovered"),
col = c("blue", "red", "green"), lty = 1, bty = "n")
# Calculate state at time step 20 using X0 %*% P^20
state_at_10 <- state_vec %*% (P %^% 10)
P <- matrix(c(
0.80, 0.20, 0.00,
0.00, 0.70, 0.30,
0.00, 0.00, 1.00
), nrow = 3, byrow = TRUE)
P <- t(p)
P <- t(P)
# Initial state vector: conditions at time step 0
state_vec <- c(0.99, 0.01, 0.00)  # The sum is 100% of the population
state_after_one <- P %*% state_vec
print(state_after_one)
# Initial state vector
state_vec <- c(0.99, 0.01, 0.00)
steps <- 150
states_vec_over_time <- matrix(0, nrow = steps, ncol = 3)
states_vec_over_time[1, ] <- state_vec
for (t in 2:steps) {
states_vec_over_time[t, ] <- states_vec_over_time[t-1, ] %*% P
}
# Plot
matplot(1:steps, states_vec_over_time, type = "l", lty = 1, col = c("blue", "red", "green"),
xlab = "Time Step", ylab = "Proportion",
main = "Markov Chain Infection Modeling")
legend("right", legend = c("Susceptible", "Infected", "Recovered"),
col = c("blue", "red", "green"), lty = 1, bty = "n")
# Calculate state at time step 20 using X0 %*% P^20
state_at_10 <- state_vec %*% (P %^% 10)
# Initial state vector
state_vec <- c(0.99, 0.01, 0.00)
steps <- 150
states_vec_over_time <- matrix(0, nrow = steps, ncol = 3)
states_vec_over_time[1, ] <- state_vec
for (t in 2:steps) {
states_vec_over_time[t, ] <- states_vec_over_time[t-1, ] %*% P
}
# Plot
matplot(1:steps, states_vec_over_time, type = "l", lty = 1, col = c("blue", "red", "green"),
xlab = "Time Step", ylab = "Proportion",
main = "Markov Chain Infection Modeling")
legend("right", legend = c("Susceptible", "Infected", "Recovered"),
col = c("blue", "red", "green"), lty = 1, bty = "n")
# Plot
matplot(1:steps, states_vec_over_time, type = "l", lty = 1, col = c("blue", "red", "green"),
xlab = "Time Step", ylab = "Proportion",
main = "Markov Chain Infection Modeling")
P <- matrix(c(
0.80, 0.20, 0.00,
0.00, 0.70, 0.30,
0.00, 0.00, 1.00
), nrow = 3, byrow = TRUE)
# Initial state vector
state_vec <- c(0.99, 0.01, 0.00)
steps <- 150
states_vec_over_time <- matrix(0, nrow = steps, ncol = 3)
states_vec_over_time[1, ] <- state_vec
for (t in 2:steps) {
states_vec_over_time[t, ] <- states_vec_over_time[t-1, ] %*% P
}
# Plot
matplot(1:steps, states_vec_over_time, type = "l", lty = 1, col = c("blue", "red", "green"),
xlab = "Time Step", ylab = "Proportion",
main = "Markov Chain Infection Modeling")
P <- matrix(c(
0.80, 0.20, 0.00,
0.00, 0.70, 0.30,
0.00, 0.00, 1.00
), nrow = 3, byrow = TRUE)
P <- t(P)
# Initial state vector
state_vec <- c(0.99, 0.01, 0.00)
steps <- 150
states_vec_over_time <- matrix(0, nrow = steps, ncol = 3)
states_vec_over_time[1, ] <- state_vec
for (t in 2:steps) {
states_vec_over_time[t, ] <- P %*% states_vec_over_time[t-1, ]
}
# Plot
matplot(1:steps, states_vec_over_time, type = "l", lty = 1, col = c("blue", "red", "green"),
xlab = "Time Step", ylab = "Proportion",
main = "Markov Chain Infection Modeling")
anova
view(anova)
res <- eigen(t(P))
res$values
res$vectors[, 1] # first eigenvector
res <- eigen(P)
res$values
res$vectors[, 1] # first eigenvector
setwd("/Users/coellearth/Desktop/HFD_Paper/Fig1_snRNA-seqProfiling")
library(SingleR)
install.packages("SingleR")
library(ggunchull)
library(ggrepel)
library(ggplot2)
library(dplyr)
setwd("/Users/coellearth/Desktop/Mammary_Gland_Diet_Project/0Subdivision")
library(Seurat)
library(dplyr)
library(tidyverse)
library(plyr)
library(glmGamPoi)
library(patchwork)
ND <- readRDS("/Users/coellearth/Desktop/Mammary_Gland_Diet_Project/*originaldata/Harmony/harmony_ND.rds")
HFD <- readRDS("/Users/coellearth/Desktop/Mammary_Gland_Diet_Project/*originaldata/Harmony/harmony_HFD.rds")
All <- readRDS("/Users/coellearth/Desktop/Mammary_Gland_Diet_Project/*originaldata/Harmony/harmony_All.rds")
Idents(ND) <- "cell_type"
Idents(HFD) <- "cell_type"
Idents(All) <- "cell_type"
# 通用的前处理函数
preprocess_subcluster <- function(obj, assay="RNA", nfeatures=2000, dims=1:20) {
obj <- NormalizeData(obj)
obj <- FindVariableFeatures(obj, nfeatures = nfeatures)
obj <- ScaleData(obj, features = VariableFeatures(obj))
obj <- RunPCA(obj, verbose = FALSE)
obj <- FindNeighbors(obj, dims = dims)
return(obj)
}
# Adipo 子聚类: Layer 1
# ND
Adipo_ND <- subset(ND, idents = "Adipo")
Adipo_ND <- preprocess_subcluster(Adipo_ND)
Adipo_ND <- FindClusters(Adipo_ND, resolution = 0.02)
Adipo_ND <- RunUMAP(Adipo_ND, dims = 1:20)
Adipo_ND.markers <- FindAllMarkers(Adipo_ND,
only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
GPT_Adipo <- subset(Adipo_ND.markers, cluster %in% c(0, 1)) |>
group_by(cluster) |>
slice_head(n = 25) |>
select(cluster, gene)
print(GPT_Adipo, n = 75)
Adipo_ND$subcluster <- mapvalues(
x = Adipo_ND$seurat_clusters,
from = c("0","1"),
to   = c("MatureAdipo","AdipoProg")
)
# HFD
Adipo_HFD <- subset(HFD, idents = "Adipo")
Adipo_HFD <- preprocess_subcluster(Adipo_HFD)
Adipo_HFD <- FindClusters(Adipo_HFD, resolution = 0.03)
Adipo_HFD <- RunUMAP(Adipo_HFD, dims = 1:20)
Adipo_HFD.markers <- FindAllMarkers(Adipo_HFD,
only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
GPT_Adipo <- subset(Adipo_HFD.markers, cluster %in% c(0, 1)) |>
group_by(cluster) |>
slice_head(n = 25) |>
select(cluster, gene)
print(GPT_Adipo, n = 75)
Adipo_HFD$subcluster <- mapvalues(
x = Adipo_HFD$seurat_clusters,
from = c("0","1"),
to   = c("MatureAdipo","AdipoProg")
)
# Adipo confirm
p1 <- DimPlot(Adipo_ND, reduction = "umap", group.by = "subcluster", label = TRUE) +
ggtitle("ND Adipocytes Subclusters")
p2 <- DimPlot(Adipo_HFD, reduction = "umap", group.by = "subcluster", label = TRUE) +
ggtitle("HFD Adipocytes Subclusters")
p1 + p2
Immune_ND <- subset(ND, idents = "Immune")
Immune_ND <- preprocess_subcluster(Immune_ND)
Immune_ND <- FindClusters(Immune_ND, resolution = 0.4)
Immune_ND <- RunUMAP(Immune_ND, dims = 1:20)
Immune_ND.markers <- FindAllMarkers(Immune_ND,
only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
Immune_ND <- subset(ND, idents = "Immune")
Immune_ND <- preprocess_subcluster(Immune_ND)
Immune_ND <- FindClusters(Immune_ND, resolution = 0.4)
Immune_ND <- RunUMAP(Immune_ND, dims = 1:20)
Immune_ND.markers <- FindAllMarkers(Immune_ND,
only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
GPT_Immune_ND <- subset(Immune_ND.markers, cluster %in% c(0, 1, 2, 3, 4, 5, 6, 7)) |>
group_by(cluster) |>
slice_head(n = 10) |>
select(cluster, gene)
print(GPT_Immune_ND, n = 140)
GPT_Immune_ND <- subset(Immune_ND.markers, cluster %in% c(0, 1, 2, 3, 4, 5, 6, 7)) |>
group_by(cluster) |>
slice_head(n = 20) |>
select(cluster, gene)
print(GPT_Immune_ND, n = 140)
print(GPT_Immune_ND, n = 160)
View(GPT_Immune_ND)
